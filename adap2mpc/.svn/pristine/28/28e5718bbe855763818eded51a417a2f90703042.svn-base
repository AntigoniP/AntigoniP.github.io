
\subsubsection{Construction of 2-Round Receiver-Extractable Semi-Malicious Oblivious Transfer with Sender and Receiver Oblivious Sampling.}
\label{sec:ot-hps}


\Fnote{Name needs to be changed everywhere else}

We now construct 2-round receiver-extractable semi-malicious oblivious transfer protocols with sender and receiver oblivious sampling from IND-CPA encryption schemes and smooth projective hash functions~\cite{EC:CraSho02} (SPHFs) with the following additional properties: ciphertexts of the encryption scheme and projection keys of the SPHF can be obliviously sampled.
Our DDH-based construction is a variant of the one of Naor and Pinkas~\cite{SODA:NaoPin01} (later generalized by Halevi and Kalai~\cite{JC:HalKal12}), where some parameters are generated by a trusted party and written in the CRS, instead of being generated by the sender (in order to allow extraction of the selection bit of the receiver).
Our QR-based construction uses in addition a trick from~\cite{C:HofKil09} to allow for oblivious sampling, without requiring to perform square roots (which requires knowing the factorization of the modulus used in the construction).

Let us first define (IND-CPA) encryption schemes with ciphertext oblivious sampling and SPHFs with projection key oblivious sampling.

\begin{definition}[Encryption with Ciphertext Oblivious Sampling]
  An \emph{encryption scheme with ciphertext oblivious sampling} is a tuple of five polynomial-time algorithms $(\keygen,\enc,\enco,\encoinv,\dec)$:
  \begin{description}
  \item[Key generation:] $(\pk,\sk) \getsr \keygen(1^\secpar)$ generates a public/secret key pair $(\pk,\sk)$;
  \item[Encryption:] $\ct = \enc(\pk,m;r)$ encrypts a message $m \in \mathcal{M}$ under $\pk$ into a ciphertext $\ct$, using random tape $r$;
  \item[Oblivious encryption:] $\ct = \enco(\pk;\tilde r)$ obliviously generate a ciphertext $\ct$ from randomness $\tilde r$; $\tilde r' \gets \encoinv(\pk,\ct)$ explains the randomness for the ciphertext $\pk$;
  \item[Decryption:] $m' = \dec(\sk,\ct)$ decrypts the ciphertext $\ct$ using the secret key $\sk$;
  \end{description}
  satisfying the usual properties: perfect correctness, semantic security (IND-CPA), and:
  \begin{itemize}
  \item \textbf{Correctness.} For any security parameter $\secpar \in \N$, for any key pair $(\pk,\sk)$ in the image of $\keygen(1^\secpar)$, for any message $m \in \mathcal{M}$, for any ciphertext $\ct$ in the image of $\enc(\pk,m)$:
    \[ \dec(\sk,\ct) = m \enspace. \]
  \item \textbf{Semantic Security (IND-CPA).} For any polynomial-time circuit family $\advA =\smallset{\advA_\secpar}_{\secpar \in \N}$,
    there exists a negligible function $\negl$, such that for any $\secpar \in N$:
    \begin{multline*}
      \bigg| 2 \cdot \Pr\bigg[ \advA_\secpar(\state, \ct) \ : \ 
    \end{multline*}
  \item \textbf{Obliviousness.} For any $(\pk,\sk) \getsr \keygen(1^\secpar)$, the following two distributions are computationally indistinguishable:
    \begin{align*}
      &\set{(\ct,\tilde r') \ : \ m \getsr \mathcal{M}; \ \ct \getsr \enc(\pk,m); \ \tilde r' = \encoinv(\pk,\ct)}, \\
      &\set{(\ct,\tilde r) \ : \ \ct = \enco(\pk; \tilde r)}.
    \end{align*}
  \end{itemize}
  \Fnote{TODO write more if time}
\end{definition}

For any encryption scheme, we define the associated collection of NP languages $\smallset{\lang_{\enc,\pk}}_\pk$ of pairs $\word=(\ct,m)$ such that $\ct$ is a valid encryption of $m$ under $\pk$. More formally $(\ct,m) \in \lang_{\enc,\pk}$ if there exists a random tape $r$ such that $\ct = \enc(\pk,m;r)$.
The random tape $r$ is the witness $\wit$.
\Fnote{Setup for language parameter...}

\begin{definition}[SPHF with Projection Key Oblivious Sampling]
  A \emph{smooth projective hash function (SPHF) with projection key oblivious sampling} for a collection of languages $\smallset{\lang_\pk}_\pk$ is a tuple of five algorithms $(\HashKG,\ProjKGO,\ProjKGOinv,\Hash,\allowbreak\ProjHash)$:
  \begin{description}
  \item[Hashing key generation:] $(\hk,\hp) \getsr \HashKG(\word)$ generates a hashing key $\hk$ (i.e., a secret key) and an associated projection key $\hp$ (i.e., a public key) for~$\word$.
  \item[Projection key oblivious sampling:] $\hp = \ProjKGO(\word;\tilde \rho)$ obliviously sample a projection key from randomness $\tilde \rho$; $\tilde \rho' \getsr \ProjKGOinv(\word,\hp)$ explains the randomness for the projection key $\hp$.
  \item[Hashing:] $\HH = \Hash(\hk,\word)$ computes the hash value $\HH \in \bits$ of $\word$ for $\hk$.\footnote{We remark that we just need SPHF where hash values are only a single bit.}
  \item[Projected hashing:] $\projH = \ProjHash(\hp,\word,\wit)$ computes the projected hash value $\projH \in \bits$ of $\word$ for $\hk$.
  \end{description}
  satisfying the following properties:
  \begin{itemize}
  \item \textbf{Correctness.} For any $\word \in \lang$ with witness $\wit$, for any $(\hk,\hp) \getsr \HashKG(\word)$:
    \[ \Hash(\hk,\word) = \ProjHash(\hp,\word,\wit) \]
  \item \textbf{Smoothness.} For any $\word \notin \lang$, the following two distributions are statistically indistinguishable:
    \begin{align*}
      &\set{(\hp,\HH) \ : \ (\hk,\hp) \getsr \HashKG(\word); \ \HH = \Hash(\hk,\word) } \\
      &\set{(\hp,\projH) \ : \ (\hk,\hp) \getsr \HashKG(\word); \ \HH \getsr \bits}
    \end{align*}
  \item \textbf{Obliviousness.} For any $\word$ (whether in $\lang$ or not)\Fnote{to fix in eprint: the $\pk$ part needs be supposed to be well-formed... but no time to write this down formally. This is required for QR, but is not much of an issue. Basically needs a parameter for language and a parameter setup}, the following two distributions are computationally indistinguishable:
    \begin{align*}
      &\set{(\hp,\tilde \rho') \ : \ (\hk,\hp) \getsr \HashKG(\word);\ \tilde \rho' \getsr \ProjKGOinv(\word,\hp)}, \\
      &\set{(\hp,\tilde \rho)  \ : \ \hp = \ProjKGO(\word;\tilde \rho)}.
    \end{align*}
  \end{itemize}
\end{definition}

\begin{theorem}\label{th:ot-hps}
  Assuming the existence of an encryption scheme with ciphertext oblivious sampling and of an SPHF with projection key oblivious sampling for the associated language, there exists a two-round receiver-extractable semi-malicious oblivious transfer protocol with sender and receiver oblivious sampling in the CRS model.
\end{theorem}

{\small\BPR [Semi-Malicious OT protocol $\eot$]\label{prot:hpsot}
  Protocol $\eot = (\eotsetup,\allowbreak\eotsetupb,\allowbreak\eotsendone,\eotsendtwo,
  \allowbreak\eotoutput,\allowbreak\eootsendtwo,\allowbreak\iotsendtwo,\allowbreak\eotextr)$ is run between sender S and receiver R.
  It uses an encryption scheme with ciphertext oblivious sampling $(\keygen,\enc,\enco,\encoinv,\dec)$ and an SPHF with projection key oblivious sampling $(\HashKG,\ProjKGO,\ProjKGOinv,\Hash,\ProjHash)$ for $\lang_\enc$
  \BI
\item \textsc{Inputs:} S holds two bits $\otmsg_0, \otmsg_1 \in \bits$ and R holds a bit $\otsel$.\footnote{Extension to strings $\otmsg_0,\otmsg_1$ can be done by repeating the second flow in parallel, keeping a unique first flow.}
\item \textsc{Setup} $\eotsetup(1^\secpar)$:
  \BI
\item[] Run $(\pk,\sk) \getsr \keygen(1^\secpar)$ and set $(\crs,\tex) = (\pk,\sk)$.
  \EI
\item \textsc{First Round} $\eotsendone(\crs,\otsel;r)$: 
  \BI
\item[] Execute $\otflowone = \ct = \enc(\pk,\otsel;r)$ and output $\otflowone$.
  \EI
\item \textsc{Second Round} $\eotsendtwo(\crs,\otflowone,\otmsg_0,\otmsg_1)$:\Fnote{in similar protocols, randomness is specified but not used, to fix later for eprint version}
  \BE
\item For $b \in \bits$, generate $(\hk_b,\hp_b) = \HashKG((\pk,\ct,b))$;
\item For $b \in \bits$, compute $\HH_b = \Hash(\hk_b,(\pk,\ct,b))$ and set $\otflowtwo_b = \HH_b \xor \otmsg_b$;
\item Output the message $\otflowtwo = (\hp_0,\hp_1,\otflowtwo_0,\otflowtwo_1)$
  \EE
\item \textsc{Output} $\eotoutput((\hp_0,\hp_1,\otflowtwo_{0},\otflowtwo_{1}),\otsel,r)$: 
  \BI
\item[] Compute $\projH = \ProjHash(\hp_\otsel,(\pk,\ct,\otsel),r)$ and output $\projH \xor \otflowtwo_\otsel$;
  \EI
\item \textsc{Receiver Extraction} $\eotextr(\pk,\sk,\ct)$
  \BI
\item[] Output $\otsel$ if $\dec(\sk,\ct) = \otsel \in \bits$ or $\perp$ otherwise;
  \EI
\item \textsc{Receiver's Oblivious Flow:}
  \BI
\item $\ootsendone(\crs;\tilde r) = \enco(\pk; \tilde r)$
\item $\iotsendone(\crs,\otflowone) = \encoinv(\pk, \otflowone)$
  \EI
\item \textsc{Sender's Oblivious Flow:}
  \BI
\item $\ootsendtwo(\crs;\tilde zeta)$ parses $\tilde \zeta = (\tilde \rho_0,\tilde \rho_1,\otflowtwo_0,\otflowtwo_1)$, computes $\hp_b = \ProjKGO((\pk,\ct,b);\tilde \rho_b)$ for $b \in \bits$, and outputs $(\hp_0,\hp_1,\otflowtwo_0,\otflowtwo_1)$
\item $\iotsendtwo(\crs,(\hp_0,\hp_1,\otflowtwo_0,\otflowtwo_1))$ computes $\tilde \rho_b' = \ProjKGOinv((\pk,\ct,b),\hp_b)$ for $b \in \bits$ and outputs $(\tilde \rho_0,\tilde \rho_1,\otflowtwo_0,\otflowtwo_1)$
  \EI
  \EI
  \EPR}

\begin{proof}[Proof of \cref{th:ot-hps}]
  Correctness follows from the correctness of the encryption scheme and of the SPHF.
  Security against a malicious receiver and extraction follows from the perfect correctness of the encryption scheme and the smoothness: if $\dec(\sk,\ct) \neq b$, then smoothness ensures that even given $\hp_b$, $\HH_b$ is statistically close to uniform from the adversarial receiver point of view.
  Security against a semi-malicious sender comes from the fact that the encryption scheme is IND-CPA and thus $\ct$ can be replaced by the encryption of a random message.
  \Fnote{needs to write more in eprint}
\end{proof}

We conclude by exhibiting concrete instantiations from DDH and QR. 

\begin{example}[Instantiation from DDH]
  The encryption scheme is ElGamal in any group $\G$ of prime order $p$ where DDH holds, which is ciphertext oblivious samplable (assuming that we can obliviously sample group elements):
  \begin{itemize}
  \item \textsc{Key generation:} $\keygen$ generate a random generator $g$ of $\G$, and a random scalar $s \getsr \Z_p$. The secret key is $\sk = (g,s)$, while the public key is $\pk = (g,h)$, with $h = g^s$;
  \item \textsc{Encryption:} $\enc(\pk,m)$ samples $r \getsr \Z_p$, and outputs $\ct = (g^r, h^r m)$;
  \item \textsc{Decryption:} $\dec(\sk, (u,v))$ outputs $v / u^s$;
  \item \textsc{Oblivious encryption:} $\enco(\pk;\tilde r)$ obliviously samples from $\tilde r$ two group elements $(u,v)$ and outputs $(u,v)$; $\encoinv$ does the inverse operation.
  \end{itemize}
  The SPHF is the following from~\cite{EC:CraSho02} (we recall that $\word = (\pk,\ct,m)$ and $\wit =r$):
  \begin{itemize}
  \item \textsc{Hashing key generation:} $(\hk,\hp) \getsr \HashKG(\word)$ generates $(\alpha,\beta)\gets \Z_p^2$, outputs $\hk = (\alpha,\beta)$ and $\hp = g^\alpha h^\beta$;
  \item \textsc{Projection key oblivious sampling:} $\hp = \ProjKGO(\word;\tilde \rho)$ obliviously sample a random group element $\hp$ from randomness $\tilde \rho$; $\tilde \rho' \getsr \ProjKGOinv(\word,\hp)$ does the inverse operation.
  \item \textsc{Hashing:} $\HH = \Hash(\hk,\word)$ outputs the hash value $\HH = u^\alpha {(v/m)}^\beta$, where $\ct = (u,v)$.
  \item \textsc{Projected hashing:} $\projH = \ProjHash(\hp,\word,\wit)$ outputs the value $\projH = \hp^r$.
  \end{itemize}
  The ElGamal encryption scheme is IND-CPA under the Decisional Diffie-Hellman (DDH) assumption, so the resulting OT is secure under DDH.
\end{example}

\begin{example}[Instantiation from QR]
  The encryption scheme is a variant of the Goldwasser-Micali~\cite{JCSS:GolMic84} encryption scheme modulo an RSA modulus $N=pq$ product of two safe primes:
  \begin{itemize}
  \item \textsc{Key generation:} $\keygen$ generate a two safe primes $p=2p'+1$ and $q=2q'+1$, where $p'$ and $q'$ are two distinct large enough primes, and generates a generator $g$ of the cyclic group $\Jacob_N$ of elements of Jacobi symbol $1$ and $y$ an element of Jacobi symbol $-1$, and outputs $\pk = (N,g,y)$ and $\sk = (p,q)$.
  \item \textsc{Encryption:} $\enc(\pk,m)$ samples a large enough integer $r$ and outputs $\ct = g^{2r} {(-1)}^m$.\footnote{The squaring of $g$ is used to allow for oblivious sampling of the projection key of the associated SPHF. We remark that $g$ and $g^2$ generate the same subgroup of $\Z_N^*$.}
  \item \textsc{Decryption:} $\dec(\sk, \ct)$ return $0$ if and only if $\ct$ is a quadratic residue (which can be checked efficiently knowing the factorization of $N$); and $1$ otherwise;
  \item \textsc{Oblivious encryption:} $\enco(\pk; \tilde r)$ obliviously samples from $r$ an element of $\Jacob_N$, which can be done by reducing $r$ modulo $N$ and checking if it is in $\Jacob_N$; and if it is not, by multiplying the resulting element by $y$; $\encoinv$ does the inverse operation.
  \end{itemize}
  We recall that $\word = (\pk,\ct,m)$ and $\wit =r$.
  We describe a variant of SPHF with a weaker smoothness property, namely the hash value of a word outside the language has min-entropy 1, instead of being statistically indistinguishable from uniform.
  This can be transformed into a real SPHF by parallel repetitions and using a strong randomness extractor (see \cite{EC:CraSho02}).
  This transformation preserves projection key oblivious sampling.
  The construction is inspired from the QR SPHF of~\cite{EC:CraSho02} but is changed in a way that the membership to the set of projection keys can be publicly verifiable.
  More precisely, in the former construction, projections keys are quadratic residues, while in our constructions, we use signed quadratic residues~\cite{C:HofKil09} which are easily recognizable even without knowing the factorization of $N$.
  The group of signed quadratic residues is $\SQR_N = \set{|x| \ : \ x \in \QR_N}$, where $\QR_N$ is the group of quadratic residues and $|x|$ denotes the absolute value of $x \in \Z_N^*$ when seen as an integer in $\{-(N-1)/2,\dots,(N-1)/2\}$. This group is the same as $\Jacob_N^+ = \set{|x| \ : \ x \in \Jacob_N}$.
  \begin{itemize}
  \item \textsc{Hashing key generation:} $(\hk,\hp) \getsr \HashKG(\word)$ generates a large enough integer $\alpha$, and outputs $\hk = \alpha$ and $\hp = |g^\alpha|$;
  \item \textsc{Projection key oblivious sampling:} $\hp = \ProjKGO(\word;\tilde \rho)$ obliviously sample a random element $\hp \in \SQR_N = \Jacob_N^+$ from randomness $\tilde \rho$, by sampling an element of $\Jacob_N$ as for the oblivious encryption and taking its absolute value; $\tilde \rho' \getsr \ProjKGOinv(\word,\hp)$ does the inverse operation;
  \item \textsc{Hashing:} $\HH = \Hash(\hk,\word)$ outputs the hash value $\HH = {(\ct / {(-1)}^m)}^\alpha$;
  \item \textsc{Projected hashing:} $\projH = \ProjHash(\hp,\word,\wit)$ outputs the value $\projH = \hp^{2r}$.
  \end{itemize}
  Correctness of the resulting SPHF comes from the fact that $\HH = {(\ct / {(-1)}^m)}^\alpha = g^{2r\alpha} = {(|g^\alpha|)}^{2r} = \hp^{2r}$. This is where we see the importance of defining $\ct = g^{2r} {(-1)}^m$ instead of the more classical $\ct = g^r {(-1)}^m$.
  Smoothness of the resulting SPHF is argued exactly like in~\cite{EC:CraSho02}: the hash value of a word $\word \notin \lang$ (i.e., $(\ct / {(-1)}^m) \in \Jacob_N^* \setminus \QR_N$) is uniform among two opposite values when only conditioned on knowing $\hp$.
  Finally, the above encryption scheme is IND-CPA under the quadratic residuosity (QR) assumption, so the resulting OT is secure under QR.
\end{example}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
