
\section{Introduction}
\label{sec:intro}

Some thoughts on the intro. 

MPC. 

static security vs adaptive security. we focus on the setting where every one can be corrupted. 

Advances in adaptive security has been slow. O(1)-round static security in the plain model was known in the 80's, but O(1)-round adaptive security starts from 2009 in the CRS model and 2XXX (Garg-Sahai, Muthu) in the plain model. Recent advances has drove down the exact complexity of static secure MPC [....], leading to an array of 2-round MPC protocols in the CRS model from various assumptions.... [....] , even from the necessary assumption of malicious OT in the CRS model[GargSrin]. In contrast, 2-round adaptive security is only known under subexponentially secure IO. Thus we ask: 

Can we have 2-round adaptively secure MPC from standard assumptions? 

In fact, the feasibility of 2-round adaptive security remains open even in the restricted 2PC setting, and even for the specific 2PC functionality of OT. . what is known.... 

Can we have 2-round adaptively secure OT and 2PC from standard assumptions? 

\anti{
 (1st question:) it was open on how to do optimal round adaptive MPC from standard assumptions (2nd question) even in the 2 party case we do not know optimal round adaptive from standard assumptions ( STOC adaptive garbling paper did only semi-honest 2 round) (3rd question) so even optimal round adaptive OT is not known from standard assumptions?}
 
\subsection{Our Results}
 
mention the theorems only in the semi-malicious case; both theorems for MPC and OT, 
 
add a line at the end saying that we can get malicious applying UC adaptive NIZK. 
 
\subsection{Our Techniques}

In~\cite{STOC:CLOS02}, Canetti, Lindell, Ostrovsky, and Sahai show how to construct a 2-round adaptive semi-honest OT, from augmented non-committing encryption (augmented meaning that it is possible to obliviously sample a public key).
The construction is simple and elegant: the receiver generates two non-committing encryption public keys. The one corresponding to its input $\otsel$ is generated correctly with the associated secret key, while the other one is generated obliviously.
The sender then encrypts its first input $\otmsg_0$ under the first key and its second input $\otmsg_1$ under the second key.
The receiver can then decrypts $\otmsg_\otsel$.
Unfortunately, this construction does not achieve security against a semi-malicious adversary, as such an adversary can use the same strategy as a simulator simulating an honest receiver, namely: it can generate two valid public keys and ``claim'' that one is obliviously generated.


Our construction of 2-round adaptive semi-malicious OT uses different methods to avoid this issue.
Let us now give a high-level overview of our construction.
%We consider a sender with two input bits $\otmsg_0,\otmsg_1$ and a receiver with an input selection bit $\otsel$.
%
Compared to 2-round static semi-malicious OT, adaptive OT needs to provide a way to equivocate the sender and the receiver flows at the end. There are three kinds of equivocation:
\begin{enumerate}
\item equivocation of the receiver at the end;
\item equivocation of the sender at the end, while the receiver was malicious at the beginning;
\item equivocation of the sender at the end, while the receiver was honest at the beginning.
\end{enumerate}

We first remark that the third kind of equivocation is easy to achieve by making the receiver sends a public key for a non-committing encryption scheme in the first flow, and the sender encrypting its flow under this key.
This way, if the sender is corrupted at the end, we can just equivocate its flow to contain an honestly-generated sender-flow for the learned bits $\otmsg_0,\otmsg_1$.

To build a scheme satisfying the first two equivocation properties, we follow these steps.

\subparagraph{Step 1: 2-round static OT with oblivious samplability and extraction.}
We start from a 2-round (static) semi-malicious OT with the following additional properties:
\begin{enumerate}
\item the sender flow can be sampled obliviously;
\item the receiver flow can be sampled obliviously;
\item the input $\otsel$ can be extracted from a malicious receiver.
\end{enumerate}
\Fnote{This is not exactly true.}
Oblivious sampling is a much weaker property than equivocation.
A variant of the oblivious transfer from Naor and Pinkas~\cite{SODA:NaoPin01} (later generalized by Halevi and Kalai~\cite{JC:HalKal12}) based on the Decisional Diffie-Hellman (DDH) assumption, where some elements of the first flow are generated by a trusted party and written in the CRS, instead of being generated by the sender (in order to allow extraction of the selection bit of the receiver) can be used.
More generally, we show how to construct such OT from encryption schemes with ciphertext oblivious sampling and smooth projective function (or hash proof systems, a primitive introduced by Cramer and Shoup in~\cite{EC:CraSho02}) with some obliviousness property.
In particular, this generic construction can also be instantiated from the Quadratic Residuosity (QR) assumption.

\subparagraph{Step 2: adding equivocation of the sender.}
We show a generic transformation from any 2-round static OT with oblivious samplability and extraction to a similar OT with in addition equivocation of the sender (against a malicious sender).

The first idea to achieve this property is to run the original protocol twice in parallel.
The receiver would use the same input $\otsel$ for both executions, while the sender would generates one of its flow normally with its inputs $(\otmsg_0,\otmsg_1)$ and one obliviously.
To allow the receiver to know which flow was obliviously generated, we can suppose that our new protocol works with sender bit inputs, but the original protocol works with sender string inputs, so that an obliviously sampled sender flow corresponds to a random string which is unlikely to be equal to a bit. Thus the receiver can know which flow to use.
The simulator of an honest sender against a maliciours receiver would first extract $\otsel$ from the flows of the receiver, get $\otmsg_\otsel$ and then generate both sender flows non-obliviously using $\otmsg_\otsel$ and $\otmsg_{1-\otsel}=0,1$.


Unfortunately, this idea does not work for at least three reasons:
\begin{enumerate}
\item The simulated sender is not indistinguishable from a real sender, as even an honest sender would get from both these flows, the same output $\otmsg_\otsel$, while for a real sender, one of these outputs is uniformly random.
\item A semi-malicious sender can generate the first flow for $(0,0)$ and the send flow for $(1,1)$, which would break correctness (an honest receiver would not know which value to output).
\item The receiver can use a different input $\otsel$ for each of its flows, in which case extraction will fail.
\end{enumerate}

To solve the first issue, the OT is repeated four times, still with the same receiver input $\otsel$. The two first times are used for $\otmsg_0$: the sender generates one of the two corresponding flows obliviously, and generate the other for $(\otmsg_0,s_0)$, with $s_0$ a random string.
Similarly, the two second times are used for $\otmsg_1$.

To solve the second issue, we make the sender commit to $\otmsg_0$ and $\otmsg_1$ with an equivocal commitment scheme: $\com_0 = \Com(\otmsg_0;\rho_0)$ and $\com_1 = \Com(\otmsg_1;\rho_1)$. Then, it uses the following inputs $\otmsg_0 \| \rho_0$ and $\otmsg_1 \| \rho_1$ to generate its flows, instead of $\otmsg_0$ and $\otmsg_1$.
On the one hand, a malicious sender cannot open an equivocal commitment to both $0$ and $1$, so that it cannot misbehave as in the second issue.
On the other hand, a simulator can open the equivocal commitment both to $0$ and $1$ and its simulation strategy still works.


To solve the third issue, we change the protocol so that the receiver only sends a single flow instead of four, which is then re-used four times in parallel by the sender.

\subparagraph{Step 3: adding equivocation of the receiver.}
The final step is to add equivocation of the receiver.
For that, we combine the OT with garbled circuits using techniques reminiscent of~\cite{C:CDGGMP17,C:DotGar17,EC:BenLin18,EC:GarSri18}.

The first idea is similar to the idea to construct non-committing encryption in~\cite{AC:CDMW09}.
We run in parallel $4 \secpar$ OT.
The sender generates $4 \secpar$ first flows (with $\secpar$ the security parameter): a random $\secpar$-size subset of them is generated correctly for its input $\otsel$, while the $3\secpar$ others are obliviously sampled.
The receiver similarly selects $\secpar$ executions and generate its flow correctly for them (for its inputs $(\otmsg_0,\otmsg_1)$).
It samples obliviously the $3\secpar$ other sender flows.
This allows a simulator of an honest receiver to generate $\secpar$ flows for $\otsel=0$, $\secpar$ flows for $\otsel=1$, and $2\secpar$ flows obliviously; and so later to equivocate its randomness to match either $\otsel = 0$ or $\otsel = 1$.
\Fnote{$2$ flows from receiver should be sufficient instead of this.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
